<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG - Mouvement sur Grille</title>
    <style>
        /* --- Le CSS est essentiel pour que les éléments soient visibles --- */
        body {
            background-color: #1a1a1a;
            font-family: sans-serif;
            margin: 0;
            /* Empêche le défilement de la page entière */
            overflow: hidden; 
        }
        #game-container { 
            /* Il doit être décalé pour ne pas être caché par les barres fixes */
            margin-left: 300px; /* Largeur de la barre latérale */
            height: 100vh;
            padding-bottom: 70px; /* Hauteur de la barre d'actions */
            box-sizing: border-box;
        }
        #scroll-wrapper {

            /* Pour centrer la carte de jeu à l'intérieur */
            width: 100%;
            height:100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /*Ajout de barre de défilement*/
            overflow: auto; 

        }

        #game-world {
            position: relative;
            border: 2px solid #555;
            background-color: #333; /* Fond pour voir le conteneur */
            flex-shrink: 0; /* Empêche la carte de se réduire */
        }

        .tile {
            position: absolute;
            box-sizing: border-box;
        }
        
        .floor {
            background-color: #7a6a53;
        }

        .wall {
            background-color: #3d352b;
        }



        /* Style générique pour tous les personnages */
        .character {
            position: absolute;
            z-index: 10;
            /* La transition est maintenant plus douce */
            transition: top 0.3s linear, left 0.3s linear;
            border-radius: 5px; /* Pour un look un peu plus sympa */
            display: flex;  /* Permet de centrer l'indicateur */
            justify-content: center;
        }

        .direction-indicator {
            width: 0;
            height: 0;
            /* Crée un triangle pointant vers le haut */
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 12px solid rgba(0,0,0,0.5);
        }

        /* Classes pour la rotation */
        .dir-up { transform: rotate(0deg); }
        .dir-right { transform: rotate(90deg); }
        .dir-down { transform: rotate(180deg); }
        .dir-left { transform: rotate(270deg); }

        #info-panel {
            position: fixed; /* Fixe par rapport à la fenêtre */
            top: 0;
            left: 0;
            width: 300px; /* Largeur fixe */
            height: 100vh; /* Toute la hauteur de l'écran */
            background-color: #2c2c2c;
            color: white;
            padding: 15px;
            box-sizing: border-box; /* Le padding ne s'ajoute pas à la largeur */
            overflow-y: auto; /* Active le scroll si le log est long */
            z-index: 100;
            border-right: 2px solid #555;
        }

        #action-bar {
            position: fixed;
            bottom: 0;
            left: 300px; /* Commence après la barre latérale */
            right: 0; /* S'étend sur le reste de la largeur */
            height: 70px; /* Hauteur fixe */
            background-color: #2c2c2c;
            border-top: 2px solid #555;
            z-index: 100;

            /* Pour centrer les boutons */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px; /* Espace entre les boutons */
        }

        #action-bar button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

    </style>
</head>
<body>

    <div id="info-panel">
        <p>Bienvenue dans ce magnifique jeu !</p>
        <p>Utilisez les flèches pour vous déplacer.</p>
    </div>

    <main id="game-container">
        <div id="scroll-wrapper">
            <div id="game-world"> </div> 
        </div>
    </main>

    <div id="action-bar">
        <button id="btn-pivot-left">↶ Pivoter G.</button>
        <button id="btn-advance">↑ Avancer</button>
        <button id="btn-pivot-right">Pivoter D. ↷</button>
        <button id="btn-shout">Crier</button>
    </div>

    


<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script>
    // Connexion au serveur WebSocket
    const socket = io();
    const infoPanel = document.getElementById('info-panel');
    let TILE_SIZE = 40;
    let localGameState = null; // Pour stocker l'état du jeu reçu
// --- GESTION DES BOUTONS D'ACTION ---

    // Fonction centrale pour envoyer une action au serveur
    function sendAction(actionObject) {
        socket.emit('action', actionObject);
    }

    // On lie chaque bouton à une action spécifique
    document.getElementById('btn-pivot-left').addEventListener('click', () => {
        sendAction({ type: 'pivot', turn: 'left' });
    });

    document.getElementById('btn-pivot-right').addEventListener('click', () => {
        sendAction({ type: 'pivot', turn: 'right' });
    });

    document.getElementById('btn-advance').addEventListener('click', () => {
        sendAction({ type: 'advance' });
    });

    document.getElementById('btn-shout').addEventListener('click', () => {
        const shout = prompt("Que voulez-vous crier ?");
        sendAction({ type: 'shout', message: shout });
    });

    // Cette nouvelle fonction redessine tout à partir des données reçues
    function drawGameState(state) {
        const gameWorld = document.getElementById('game-world');
        gameWorld.innerHTML = ''; // On vide le monde à chaque mise à jour

        const mapLayout = state.map;
        const MAP_WIDTH = mapLayout[0].length;
        const MAP_HEIGHT = mapLayout.length;

        gameWorld.style.width = `${MAP_WIDTH * TILE_SIZE}px`;
        gameWorld.style.height = `${MAP_HEIGHT * TILE_SIZE}px`;

        // 1. Dessiner la carte
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                const tileType = mapLayout[y][x];
                const tileClass = tileType === 1 ? 'wall' : 'floor';
                const tileDiv = document.createElement('div');
                tileDiv.className = `tile ${tileClass}`;
                tileDiv.style.left = `${x * TILE_SIZE}px`;
                tileDiv.style.top = `${y * TILE_SIZE}px`;
                tileDiv.style.width = `${TILE_SIZE}px`;
                tileDiv.style.height = `${TILE_SIZE}px`;

                gameWorld.appendChild(tileDiv);
            }
        }

        // 2. Dessiner tous les personnages
        for (const char of state.characters) {
            const charDiv = document.createElement('div');
            charDiv.id = char.id;
            charDiv.className = `character dir-${char.direction}`; // Utiliser une classe générique
            charDiv.style.left = `${char.x * TILE_SIZE}px`;
            charDiv.style.top = `${char.y * TILE_SIZE}px`;
            charDiv.style.width = `${TILE_SIZE}px`;
            charDiv.style.height = `${TILE_SIZE}px`;

            // On peut même utiliser la couleur définie sur le serveur !
            charDiv.style.backgroundColor = char.color || '#e04b4b'; 
            
            // On ajoute l'indicateur de direction visuel
            const indicator = document.createElement('div');
            indicator.className = 'direction-indicator';
            charDiv.appendChild(indicator);

            
            gameWorld.appendChild(charDiv);
        }
    }

    // On écoute l'événement 'update_state' envoyé par le serveur
    socket.on('update_state', function(state) {
        console.log("Nouvel état reçu :", state);
        localGameState = state; // On sauvegarde le dernier état connu
        drawGameState(state);
    });

    // NOUVELLE PARTIE : On écoute les touches du clavier pour envoyer des ordres
    document.addEventListener('keydown', function(event) {
        let action = null;
        switch (event.key) {
            case "ArrowUp":    action = { type: 'advance' };    break;
            case "ArrowLeft":  action = {type :'pivot' , turn:'left'};  break;
            case "ArrowRight": action = { type: 'pivot', turn: 'right'}; break;
            case "c": // La touche "C" pour crier
                const shout = prompt("Que voulez-vous crier ?");
                //if (shout) { 
                action = { type: 'shout', message: shout };
                //}
                break;
        }

        if (action) {
            // On envoie l'ordre de mouvement au serveur
            socket.emit('action', action );
        }
        // NOUVEAU : On gère le zoom si aucune action n'a été faite
        let zoomChanged = false;
        if (event.key === '+') {
            TILE_SIZE += 5; // Augmente la taille des cases
            zoomChanged = true;
        } else if (event.key === '-') {
            // On s'assure que la taille ne devient pas trop petite
            TILE_SIZE = Math.max(10, TILE_SIZE - 5); 
            zoomChanged = true;
        }

        // Si le zoom a changé, on redessine toute la scène
        if (zoomChanged && localGameState) {
            drawGameState(localGameState);
        }


    });
        // Dans votre script principal


    socket.on('log_message', function(data) {
        // 1. On crée un nouvel élément paragraphe
        const newMessage = document.createElement('p');
        newMessage.textContent = data.text; // .textContent est plus sûr que .innerHTML

        // 2. On ajoute le nouveau message au début du panneau
        infoPanel.prepend(newMessage);
    });

   // NOUVEAU: Écouter les sons entendus pour les afficher dans le log
    socket.on('sound_heard', function(data){
        const infoPanel = document.getElementById('info-panel');
        const newMessage = document.createElement('p');
        newMessage.textContent = `Vous entendez ${data.from_id.substring(0,5)}... crier : ${data.message}`;
        infoPanel.prepend(newMessage);
    });

    // --- GESTION DU ZOOM TACTILE (Version Améliorée) ---

    const gameContainer = document.getElementById('game-container');
    const gameWorld = document.getElementById('game-world'); // On récupère aussi le monde du jeu

    let initialPinchDistance = null;
    let lastTileSizeOnPinchStart = TILE_SIZE;

    // Détecte le début du pincement
    gameContainer.addEventListener('touchstart', function(event) {
        if (event.touches.length === 2) {
            event.preventDefault();
            initialPinchDistance = Math.hypot(
                event.touches[0].pageX - event.touches[1].pageX,
                event.touches[0].pageY - event.touches[1].pageY
            );
            lastTileSizeOnPinchStart = TILE_SIZE;
        }
    });

    // Gère le mouvement des doigts
    gameContainer.addEventListener('touchmove', function(event) {
        // On s'assure qu'un pincement est bien en cours
        if (event.touches.length === 2 && initialPinchDistance !== null) {
            event.preventDefault();

            const currentPinchDistance = Math.hypot(
                event.touches[0].pageX - event.touches[1].pageX,
                event.touches[0].pageY - event.touches[1].pageY
            );
            
            // On calcule le ratio de zoom en temps réel
            const zoomRatio = currentPinchDistance / initialPinchDistance;

            // On applique un zoom visuel temporaire et très rapide avec CSS
            gameWorld.style.transform = `scale(${zoomRatio})`;
            // NOTE : On ne lance PAS drawGameState() ici !
        }
    });

    // Détecte la fin du pincement
    gameContainer.addEventListener('touchend', function(event) {
        if (initialPinchDistance !== null) {
            // On remet la transformation CSS à zéro
            gameWorld.style.transform = 'none';

            // On recalcule le ratio final une dernière fois
            // Note: event.touches est vide ici, on ne peut pas s'en servir.
            // On se base sur la dernière position connue via le transform.
            // Pour simplifier, on recalcule la nouvelle TILE_SIZE à partir du dernier ratio connu
            const finalTransform = gameWorld.style.transform;
            // La ligne ci-dessus est juste pour illustrer, en pratique le ratio est déjà connu.
            // Le calcul final se fait avec les dernières valeurs avant le touchend.
            // Pour être précis, on le fait ici.
            // C'est une simplification, le calcul du ratio final est complexe au touchend,
            // donc on va plutôt mettre à jour TILE_SIZE dans le touchmove
            // et ne lancer le redraw qu'au touchend.
            
            // *** Approche Corrigée et Simplifiée ***
            // Recalculons la nouvelle TILE_SIZE à partir du dernier état connu
            const currentTransform = window.getComputedStyle(gameWorld).transform;
            let scale = 1;
            if (currentTransform && currentTransform !== 'none') {
                const matrix = currentTransform.match(/matrix\((.+)\)/);
                if(matrix) scale = parseFloat(matrix[1].split(', ')[0]);
            }
            
            const newTileSize = Math.round(lastTileSizeOnPinchStart * scale);
            TILE_SIZE = Math.max(10, Math.min(150, newTileSize));

            // On lance le redessin complet UNE SEULE FOIS
            if (localGameState) {
                drawGameState(localGameState);
            }

            // On réinitialise l'état du pincement
            initialPinchDistance = null;
        }
    });
</script>
</body>
</html>